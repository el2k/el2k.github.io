<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>EffectiveC++</title>
      <link href="/2022/10/04/effectivec/"/>
      <url>/2022/10/04/effectivec/</url>
      
        <content type="html"><![CDATA[<h1 id="Effective-C"><a href="#Effective-C" class="headerlink" title="Effective  C++"></a>Effective  C++</h1><p>序言：</p><p>这篇文章主要记录学习Effective C++这本书的过程中，有所体会有所感悟的地方。</p><p>如果有错误，欢迎读者指正！</p><p><img src="/2022/10/04/effectivec/wallhaven-gpzve7_1920x1080.png"></p><h3 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h3><p>class test{</p><p>mutable bool length ;</p><p>} //这些成员变量可能总是会被更改，即使在const成员函数内</p><p>mutable释放掉non_static成员变量的bitwise constness约束</p><h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p>将non-const对象转为const对象</p><p>static_cast&lt;const TestBlock&amp;&gt;(*this)[position];</p><h3 id="确定对象被使用前已先被初始化"><a href="#确定对象被使用前已先被初始化" class="headerlink" title="确定对象被使用前已先被初始化"></a>确定对象被使用前已先被初始化</h3><p>为内置型对象进行手工初始化，因为C++不保证初始化他们</p><p>总是使用成员初始列，这样做有时候绝对必要，且又往往比赋值更加高效</p><p>当你在成员初值列中条列各个成员时，最好总是以其声明次序为次序</p><h3 id="解决“跨编译单元之初始化次序”问题"><a href="#解决“跨编译单元之初始化次序”问题" class="headerlink" title="解决“跨编译单元之初始化次序”问题"></a>解决“跨编译单元之初始化次序”问题</h3><p><img src="/2022/10/04/effectivec/fbdf151d82f7c84e6202b5c290dd261.jpg"></p><p>使用local static对象代替non-local static对象</p><p>将每个non-local static对象搬到自己的专属函数内</p><p>函数内的local static对象会在“该函数被调用期间”“首次遇上该对象之定义式”时被初始化</p><h3 id="若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="若不想使用编译器自动生成的函数，就该明确拒绝"></a>若不想使用编译器自动生成的函数，就该明确拒绝</h3><p>条款6</p><p>为驳回编译器自动提供的机能，可将相应的成员函数声明为private并且不予实现，使用像</p><p>Uncopyable这样的base class 也是一种做法（相应成员函数声明为private，并让其他对象继承）</p><h3 id="为多态基类声明virtual析构函数"><a href="#为多态基类声明virtual析构函数" class="headerlink" title="为多态基类声明virtual析构函数"></a>为多态基类声明virtual析构函数</h3><p><img src="/2022/10/04/effectivec/d39b38e5fd9b92364ccc619ce89dc69.jpg"></p><p>polymorphic(带多态性质的)base classes 应该声明一个virtual析构函数。</p><p>如果class带有任何virtual函数，它就应该有一个virtual析构函数</p><p>Class 的设计目的如果不是作为base classes使用，或不是为了具备多态性，就不应该声明virtual 析构函数</p><h3 id="别让异常逃离析构函数"><a href="#别让异常逃离析构函数" class="headerlink" title="别让异常逃离析构函数"></a>别让异常逃离析构函数</h3><p><img src="/EffectiveC/8097f3ff9fb649c75d12c45b0d42609.jpg"></p><p>一个较佳的策略是重新设计DBConn接口，使其客户有机会对可能出现的问题作出反应</p><p><strong>析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下他们（不传播）或结束程序</strong></p><p><strong>如果客户需要对某个操作函数运行期间抛出的异常作出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作</strong></p><h3 id="绝不在构造和析构过程中调用virtual函数"><a href="#绝不在构造和析构过程中调用virtual函数" class="headerlink" title="绝不在构造和析构过程中调用virtual函数"></a>绝不在构造和析构过程中调用virtual函数</h3><hr><p><strong>在构造和析构期间不要使用virtual函数，因为这类调用不下降至derived class</strong></p><p><img src="/EffectiveC/979179c09d32582556957b80289b169.jpg"></p><p><img src="/EffectiveC/44d3dd00ab84ab69d7c6a8b6ab83955.jpg"></p><p>总的来说，就是一个虚函数基类和子类都有，然后都在父类在构造函数期间就调用了那个虚函数，导致本应调用子类的虚函数调用成父类，因为父类先构造，所以绝不要在构造和析构的过程中调用virtual函数</p><h3 id="令赋值操作符返回一个reference-to-this"><a href="#令赋值操作符返回一个reference-to-this" class="headerlink" title="令赋值操作符返回一个reference  to *this"></a>令赋值操作符返回一个reference  to *this</h3><p>为了实现连环赋值，a=b=c;</p><h3 id="在operator-x3D-中处理“自我赋值”"><a href="#在operator-x3D-中处理“自我赋值”" class="headerlink" title="在operator=中处理“自我赋值”"></a>在operator=中处理“自我赋值”</h3>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2022/10/04/suan-fa/"/>
      <url>/2022/10/04/suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="数值算法"><a href="#数值算法" class="headerlink" title="数值算法"></a>数值算法</h2><p>客户端必须包含表头<numeric></numeric></p><p>SGI将他们实现于&lt;stl_numeric.h&gt;文件中</p><h4 id="accumlate"><a href="#accumlate" class="headerlink" title="accumlate"></a>accumlate</h4><p>accumulate ( v.begin(),v.end(),0); //指定计算初始值为0</p><p>accumulate ( v.begin(),v.end(),0,minus<int>()); //指定计算方式，为减法累加</int></p><h4 id="adjacent-difference"><a href="#adjacent-difference" class="headerlink" title="adjacent_difference"></a>adjacent_difference</h4><p>此算法用来计算[first,last)中相邻元素的差额</p><p>ostream_iterator<int>oite(cout, “  “);</int></p><p>adjacent_difference(v.begin(),v.end(),oite); //#1元素照录，#n新元素等于 #n旧元素—#n-1旧元素</p><p>adjacent_difference(v.begin(),v.end(),oite,plus<int>()); //#1元素照录，#n新元素等于op( #n旧元素，#n-1旧元素)</int></p><p>此算法不改变原来容器的值</p><h4 id="inner-product"><a href="#inner-product" class="headerlink" title="inner_product"></a>inner_product</h4><p>inner_product(v.begin(),v.end(),v.begin(),0); //提供初始值0，v的内积</p><p>inner_product(v.begin(),v.end(),v.end(),10,minus<int>(),plus<int>());</int></int></p><p>//提供init初始值为10，仿函数取代operator+和operator*(binary_op1,binary_op2)</p><p>//源码：init=binary_op1(init,binary_op2(* first1,* first2));</p><p>提供初值是为了防止[first,last)为空时，仍能获得一个明确定义的结果</p><h4 id="partial-sum"><a href="#partial-sum" class="headerlink" title="partial_sum"></a>partial_sum</h4><p>partial_sum(v.begin(),v.end(),oite); //第n个元素是前n个旧元素的相加总计</p><p>如：1，2 , 3 , 4 , 5 -&gt;1,3,6,10,15</p><p>partial_sum(v.begin(),v.end(),oite,minus<int>());</int></p><p>//更改运算规则为减法，第n个元素是前n个旧元素的相减总计</p><p>此算法可用来计算局部总和</p><h4 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h4><p>这个算法由SGI专属，并不在STL标准之列</p><p>它用来设定某个区间的内容使其内的每一个元素从指定的value值开始，呈现递增状态</p><p>template&lt;class ForwardIterator, class T&gt;</p><p>void iota(ForwardIterator first,ForwardIterator last,T value)</p><p>{</p><p>while(first !=last) *first++=value++;</p><p>}</p><h4 id="power"><a href="#power" class="headerlink" title="power"></a>power</h4><p>power(10,3); //10 * 10 * 10</p><p>power(10,3,plus<int>()) //10+10+10</int></p><h3 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h3><p>常用算法定义于&lt;stl_algobase.h&gt;之中</p><p>其他算法定义于&lt;stl_algo.h&gt;之中</p><h4 id="equal"><a href="#equal" class="headerlink" title="equal"></a>equal</h4><p>equal(v.begin(),v.end(),v2.begin());</p><p>//如果两个序列在[first，last)区间相等，equal()返回true</p><p>// 如果第二序列的元素比较多，多出来的元素不予考虑</p><p>equal(v.begin(),v.end(),&amp;ia[3]);</p><p>// v从[first，last)区间与ia[3]后的区间比较</p><p>equal(v.begin(),v.end(),&amp;ia[3]，less<int>());</int></p><p>//需要v的区间内每个元素都小于从ia[3]开始后相同长度的区间元素</p><p><img src="/../../../Typora/9667e269c1afc20f6c88c812ca25a36.jpg" alt="9667e269c1afc20f6c88c812ca25a36"></p><h4 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h4><p>将[first,last)内的所有元素改填新值</p><p>fill( v.begin() , v.end() ,9)</p><h4 id="fill-n"><a href="#fill-n" class="headerlink" title="fill_n"></a>fill_n</h4><p>将[first,last)内的前n个元素改填新值，返回迭代器指向被填入的最后一个元素的下一位置</p><p>fill_n( v.begin() , 3,9) ; // 从迭代器所指位置开始，填3个9</p><h4 id="iter-swap"><a href="#iter-swap" class="headerlink" title="iter_swap"></a>iter_swap</h4><p>将两个ForwardIterators 所指的对象对调</p><p>是“迭代器之value type”派上用场的一个好例子</p><p>iter_swap(ite1,ite2); //将两个迭代器所指元素对调</p><h4 id="lexicographical-compare"><a href="#lexicographical-compare" class="headerlink" title="lexicographical_compare"></a>lexicographical_compare</h4><p>以“字典排列方式”对两个序列[first1,last1)和[first2,last2)进行比较</p><p>比较操作针对两序列中的对应位置上的元素进行，并持续直到</p><p>（1）某一组对应元素彼此不相等</p><p>（2）同时到达last1和last2(当两序列的大小相同)</p><p>（3）到达last1或last2（当两序列的大小不同）</p><p><img src="/../../../Typora/1664117276965.png" alt="1664117276965"></p><p>lexicographical_compare(stra1,stra1+2,stra2,stra2+2); //对两个序列进行比较，按上面的规则</p><p>//stra1小于stra2为真</p><p>lexicographical_compare(stra1,stra1+2,stra2,stra2+2，greater<string>());//传入一个仿函数作为比较操作之用</string></p><p>//stra1大于stra2为真</p><p>拓展：为了增进效率，SGI还设计了一个特化版本，用于原生指针const unsigned char*</p><p>其中使用了C标准函数memcmp()</p><h4 id="max与min"><a href="#max与min" class="headerlink" title="max与min"></a>max与min</h4><p>max(a,b);</p><p>max(a,b,comp);</p><p>min(a,b);</p><p>min(a,b,comp);</p><p>//版本一使用对象型别T所提供的greater-than（less-than）操作符来判断大小</p><p>//版本二使用仿函数comp来判断大小</p><h4 id="mismatch"><a href="#mismatch" class="headerlink" title="mismatch"></a>mismatch</h4><p>用来平行比较两个序列，指出两者之间的第一个不匹配点</p><p>返回一对迭代器，分别指向两序列中的不匹配点</p><p>如果两序列所有元素都匹配，返回的便是两序列各自的last迭代器</p><p>缺省情况下是以equality操作符来比较元素，但允许用户指定比较操作</p><p>如果第二序列的元素个数比第一序列元素多，多出来的元素忽略不计</p><p>如果第二序列的元素个数比第一序列少，会发生未可预期的行为</p><h4 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h4><p>该函数用来交换两个对象的内容</p><h4 id="copy—-强化效率无所不用其极"><a href="#copy—-强化效率无所不用其极" class="headerlink" title="copy—-强化效率无所不用其极"></a>copy—-强化效率无所不用其极</h4><p>SGI STL的copy算法使用包括函数重载，型别特性，偏特化等编程技巧</p><p>输出区间的起点(result)与输入区间重叠，可能会有问题</p><p>如果copy算法根据所接收的迭代器的特性决定调用memmove()来执行任务</p><p>因为memmove()会把整个区间的内容复制下来，没有被覆盖的危险</p><p>copy(first,last,result);</p><h4 id="copy-backward"><a href="#copy-backward" class="headerlink" title="copy_backward"></a>copy_backward</h4><p>将[first,last)区间内的每一个元素，以逆行的方向复制到以result-1为起点，方向为逆行的区间上</p><p>跟copy()很像，就是复制的基准从起点变为终点</p><p>输出区间的起点(result)与输入区间重叠可能会出现错误结果</p><p>copy_backward(first,last,result);</p><h3 id="set相关算法"><a href="#set相关算法" class="headerlink" title="set相关算法"></a>set相关算法</h3><p>SGI为set定义了四种算法</p><p> 1.并集</p><p>2.交集</p><p>3.差集</p><p>4.对称差集</p><p>该节四种算法必须是有序区间，元素值得重复出现、</p><p>所以不适用hashtable为底层实现的hash_set,hash_map</p><p>四个算法都有四个参数</p><h4 id="set-union"><a href="#set-union" class="headerlink" title="set_union"></a>set_union</h4><p>算法set_union可构造s1，s2之并集：此集合内含s1或s2内的每一个元素</p><p>以排序区间显示，返回值是一个指向输出区间尾端的迭代器</p><p>特殊：</p><p>如果两序列内每个元素不需要唯一，那么该值在输出区间会出现max(m,n)次（取两序列中出现最多次数的序列）</p><p>两个版本：   </p><p>1  set_union(first1,last1,first2,last2,ostream_iterator<int>(cout,” “)); // 使用operator&lt;作比较</int></p><p>2此版本采用仿函数comp进行比较</p><h4 id="set-intersection"><a href="#set-intersection" class="headerlink" title="set_intersection"></a>set_intersection</h4><p>算法set_intersection可构造s1,s2之交集</p><p>此集合内含同时出现在s1和s2内的每一个元素</p><p>s1,s2及其交集都是以排序区间表示</p><p>返回值是一个指向输出区间尾端的迭代器</p><p>如果两序列内每个元素不需要唯一，那么该值在输出区间会出现min(m,n)次（取两序列中出现最少次数的序列）</p><p>两个版本：</p><p>set__intersection(first1,last1,first2,last2,ostream_iterator<int>(cout,” “)); // 使用operator&lt;作比较</int></p><p>此版本采用仿函数comp进行比较</p><h4 id="set-difference"><a href="#set-difference" class="headerlink" title="set_difference"></a>set_difference</h4><p>算法set_difference可构造s1、s2之差集</p><p>他能构造出集合s1-s2</p><p>此集合出现于s1但不出现于s2的每一个元素</p><p>以排序区间显示，返回值是一个指向输出区间尾端的迭代器</p><p>set__difference(first1,last1,first2,last2,ostream_iterator<int>(cout,” “)); // 使用operator&lt;作比较</int></p><p>此版本采用仿函数comp进行比较</p><h4 id="set-symmetric-difference"><a href="#set-symmetric-difference" class="headerlink" title="set_symmetric_difference"></a>set_symmetric_difference</h4><p>算法set_symmetric_differenc可构造出s1、s2之对称差集</p><p>他能构造出集合(s1-s2)||(s2-s1)</p><p>此集合出现于s1但不出现于s2  以及 出现于s2但不出现于s1的每一个元素</p><p>以排序区间显示，返回值是一个指向输出区间尾端的迭代器</p><p>如果两序列内每个元素不需要唯一，那么该值在输出区间会出现</p><p>|n-m|次，由哪个序列赋值由两值最大值决定</p><p>set_symmetric_difference(first1,last1,first2,last2,ostream_iterator<int>(cout,” “)); </int></p><p>第二版本：此版本采用仿函数comp进行比较</p><h3 id="head算法"><a href="#head算法" class="headerlink" title="head算法"></a>head算法</h3><p>四个heap相关算法于&lt;stl_heap.h&gt;介绍过:<br>make_heap();</p><p>pop_heap();</p><p>push_heap();</p><p>sort_heap();</p><p>SGI STL算法所在的头文件&lt;stl_algo.h&gt;内包含了&lt;stl_heap.h&gt;</p><h3 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h3><h4 id="单纯的数据处理"><a href="#单纯的数据处理" class="headerlink" title="单纯的数据处理"></a>单纯的数据处理</h4><p>这一节所列的算法，都只是单纯的数据移动、线性查找、计数、循环遍历、逐一对</p><p>元素施行指定运算操作</p><h5 id="adjacent-find"><a href="#adjacent-find" class="headerlink" title="adjacent_find"></a>adjacent_find</h5><p>找出第一组满足条件的相邻元素，返回一个迭代器</p><p>adjacent_find( v.begin() , v.end() );</p><p>//找出v之中相邻元素值相等的第一个元素</p><p>//两个操作数分别是相邻的第一元素和第二元素</p><p>有两个版本：</p><p>第一个版本是指“两元素相等”</p><p>第二个版本是指允许用户指定一个二元运算</p><p>adjacent_find( v.begin() , v.end(),equal_to<int>() );</int></p><h5 id="count-count-if"><a href="#count-count-if" class="headerlink" title="count   count_if"></a>count   count_if</h5><p><em><u>count:</u></em></p><p>count(v.begin(),v.end(),value);</p><p>运用equality操作符，将[first,last)区间内的每一个元素拿来和指定值value</p><p>比较，并返回与value相等的元素个数</p><p><u><em>count_if:</em></u></p><p>将指定操作（一个仿函数）pred实施在[first,last)区间内的每一个元素</p><p>count_if(v.begin(),v.end(),bind2nd(less<int>(),value));</int></p><h4 id="find-find-if-find-end-find-first-of"><a href="#find-find-if-find-end-find-first-of" class="headerlink" title="find,find_if,find_end,find_first_of"></a>find,find_if,find_end,find_first_of</h4><p><strong>find:</strong></p><p>根据equality操作符，循序查找[first,last)内的所有元素，找出第一个匹配者</p><p>如果找到，返回一个InputIterator指向该元素，否则返回迭代器last</p><p>find(v.begin(),v.end(),value);</p><p><strong>find_if</strong>:</p><p>根据指定的pred运算条件(仿函数)，找出第一个令pred运算结果为true者，</p><p>如果找到，返回一个InputIterator指向该元素，否则返回迭代器last</p><p>find_if(v.begin(),v.end(),bind2nd(greater<int>(),value));</int></p><p><strong>find_end:</strong></p><p>在序列一[first1,last1)所涵盖的区间中，查找序列二[first2,last2)的最后一次出现点</p><p>如果序列一之内不存在”完全匹配序列二”的子序列，便返回迭代器last1</p><p>两个版本：</p><p>第一个版本是指“两元素相等”</p><p>第二个版本是指允许用户指定一个二元运算</p><p>find_end(v.begin(),v.end(),v2.begin(),v2.end());</p><p><strong>find_first_of:</strong></p><p>本算法以[first2,last2)区间内的<u>某些元素</u>作为查找目标，寻找他们在[first1,last1)</p><p>指向序列二任意元素首次出现于第一序列的地点</p><p>两个版本：</p><p>第一个版本是指“两元素相等”</p><p>第二个版本是指允许用户指定一个二元运算</p><p>find_first_of(v.begin(),v.end(),v2.begin(),v2.end());</p><p>//找出v中子序列v2所出现的第一个位置</p><h4 id="for-each"><a href="#for-each" class="headerlink" title="for_each"></a>for_each</h4><p>将仿函数施行于[first2,last2)区间内每一个元素身上，f不可以改变元素内容，因为first和</p><p>last都是InputIterator，不保证接受赋值行为</p><p>for_each(v.begin(),v.end(),[&amp;](int t){cout&lt;&lt;t&lt;&lt;” “;});</p><h4 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h4><p>将仿函数gen的运算结果施行于[first1,last1)区间内每一个元素身上，</p><p>所谓填写，用的是迭代器所指元素之assignment操作符</p><p>generate(v.begin(),v.end(),gen());</p><h4 id="generate-n"><a href="#generate-n" class="headerlink" title="generate_n"></a>generate_n</h4><p>将仿函数gen的运算结果施行于first1迭代器开始的n个元素身上，</p><p>所谓填写，用的是迭代器所指元素之assignment操作符</p><p>generate(v.begin(),n,gen());</p><h4 id="includes-应用于有序区间"><a href="#includes-应用于有序区间" class="headerlink" title="includes(应用于有序区间)"></a>includes(应用于有序区间)</h4><p>判断序列二s2是否”涵盖于”序列一</p><p>s1和s2都必须是有序集合</p><p>其中的元素都可重复</p><p>由于判断两个元素是否相等，必须以less或greater运算为依据</p><p>如果s1和s2是递增排序：</p><p>includes(s1.begin(),s1.end(),s2.begin(),s2.end());</p><p>如果s1和s2是递减排序：</p><p>includes(s1.begin(),s1.end(),s2.begin(),s2.end(),greater<int>());</int></p><h4 id="max-element"><a href="#max-element" class="headerlink" title="max_element"></a>max_element</h4><p>这个算法返回一个迭代器，指向序列之中数值最大的元素</p><p>两个版本：</p><p>第一个版本是指operator &lt;</p><p>第二个版本是指允许用户指定一个二元运算</p><p>max_element(v.begin(),v.end());</p><p>max_element(v.begin(),v.end(),comp());</p><h4 id="merge-应用于有序区间"><a href="#merge-应用于有序区间" class="headerlink" title="merge(应用于有序区间)"></a>merge(应用于有序区间)</h4><p>将两个经过排序的集合s1和s2，合并起来置于另一端空间</p><p>所得结果也是一个有序序列。返回一个迭代器，指向最后结果序列（有剩余元素需单独copy的序列）的最后一个元素的下一位置</p><p>两个版本：</p><p>第一个版本是指operator &lt;</p><p>第二个版本是指允许用户指定一个二元运算</p><p>merge(s1.begin(),s1.end(),s2.begin(),s2.end()，result.begin());</p><p>merge(s1.begin(),s1.end(),s2.begin(),s2.end(),result.begin(),comp());</p><p>缺省状态为less比较函数</p><h4 id="min-element"><a href="#min-element" class="headerlink" title="min_element"></a>min_element</h4><p>这个算法返回一个迭代器，指向序列之中数值最小的元素</p><p>两个版本：</p><p>第一个版本是指operator &lt;</p><p>第二个版本是指允许用户指定一个二元运算</p><p>min_element(v.begin(),v.end());</p><p>min_element(v.begin(),v.end(),comp());</p><h4 id="partition-有条件的重排"><a href="#partition-有条件的重排" class="headerlink" title="partition(有条件的重排)"></a>partition(有条件的重排)</h4><p>partition会将[first,last)中的元素重新排序。所有被一元条件运算pred</p><p>判定为true的元素，都会被放在区间的前段，被判定为false的元素，都</p><p>会被放在区间的后段。这个算法不保留元素的原始相对位置。</p><p>如果需要保留原始相对位置，应使用stable_partition</p><p>partition(v.begin(),v.end()pred);</p><h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><p>移除但不删除</p><p>移除[first,last)之中所有与value相等的元素。这一算法并不真正从容器中删除那些元素，而是将每一个不与value相等的元素轮番赋值给first之后的空间。返回值ForwardIterator标志出重新整理后的<u>最后元素的下一个元素</u></p><p>array不适合使用remove和remove_if，因为array无法缩小尺寸，导致残余数据永远存在</p><p>remove(v.begin(),v.end(),6);</p><h4 id="remove-copy"><a href="#remove-copy" class="headerlink" title="remove_copy"></a>remove_copy</h4><p>remove_copy(v.begin(),v.end(),v2.begin(),6);</p><p>//结果置于另一区间</p><p>移除[first,last)区间内所有与value相等的元素，这一算法并不真正从容器中删除那些元素，而是将结果复制到一个以v2.begin()标示起始位置的容器身上，新容器可以和原容器重叠</p><p>返回值为OutputIterator指出被复制的最后元素的下一个位置</p><h4 id="remove-if"><a href="#remove-if" class="headerlink" title="remove_if"></a>remove_if</h4><p>真正从容器中删除那些元素，所有被一元条件运算pred</p><p>判定为false的元素，都会被轮番赋值给first之后的空间，返回值ForwardIterator标志重新整理后的<u>最后元素的下一个元素</u></p><p>remove_if(v.begin(),v.end(),bind2nd(less<int>(),6));</int></p><p>//删除小于6的元素，尾端可能有残余数据</p><h4 id="remove-copy-if"><a href="#remove-copy-if" class="headerlink" title="remove_copy_if"></a>remove_copy_if</h4><p>remove_copy_if(v.begin(),v.end(),v2.begin(),bind2nd(less<int>(),6));</int></p><p>//删除小于7的元素，结果置于另一区间</p><p>移除[first,last)区间内所有被pred评估为false的元素，这一算法并不真正从容器中删除那些元素，而是将结果复制到一个以v2.begin()标示起始位置的容器身上，新容器可以和原容器重叠</p><p>返回值为OutputIterator指出被复制的最后元素的下一个位置</p><h4 id="remove小结"><a href="#remove小结" class="headerlink" title="remove小结"></a>remove小结</h4><p>remove，remove_if     无论哪个版本，本质都是对容器本身进行操作</p><p>remove_copy,remove_copy_if    无论哪个版本，都能将结果赋于自身或者其他容器</p><h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><p>将[first,last)区间内的所有old_value都以new_value取代</p><p>replace(v.begin(),v.end(),6,3);</p><p>//将所有元素值为6的改为3</p><h4 id="replace-copy"><a href="#replace-copy" class="headerlink" title="replace_copy"></a>replace_copy</h4><p>将结果复制到一个以v2.begin()标示起始位置的容器身上，新容器可以和原容器重叠</p><p>返回值为OutputIterator指出被复制的最后元素的下一个位置,原序列没有任何改变</p><p>replace_copy(v.begin(),v.end(),v2.begin(),6,3)</p><h4 id="replace-if"><a href="#replace-if" class="headerlink" title="replace_if"></a>replace_if</h4><p>将[first,last)区间内所有”被pred评估为true”的元素，都以new_value取而代之</p><p>replace_if(v.begin(),v.end(),bind2nd(less<int>(),5));</int></p><h4 id="replace-copy-if"><a href="#replace-copy-if" class="headerlink" title="replace_copy_if"></a>replace_copy_if</h4><p>行为与replace_if()类似，但是新序列会被复制到result所指的区间内</p><p>返回值为OutputIterator指出被复制的最后元素的下一个位置,原序列没有任何改变</p><p>replace_copy_if(v.begin(),v.end(),v2.begin(),bind2nd(equal_to<int>(),8),9)</int></p><p>//将所有等于8的元素值，改为元素值9，结果置于另一区间</p><h4 id="replace小结"><a href="#replace小结" class="headerlink" title="replace小结"></a>replace小结</h4><p>replace，replace_if     无论哪个版本，本质都是对容器本身进行操作</p><p>replace_copy,replace_copy_if    无论哪个版本，都能将结果赋于自身或者其他容器</p><h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h4><p>将序列[first,last)的元素在原容器中颠倒重排</p><p>迭代器的双向或随机定位能力，影响了这个算法的效率，所以设计为双层架构</p><p> <a href="https://blog.csdn.net/Johnsonjjj/article/details/107783210?ops_request_misc=%7B%22request_id%22:%22166445625716800182132986%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&amp;request_id=166445625716800182132986&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-107783210-null-null.142%5Ev51%5Econtrol,201%5Ev3%5Econtrol_2&amp;utm_term=%E5%8F%8C%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%88%A4%E6%96%AD%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%A7%E5%B0%8F&amp;spm=1018.2226.3001.4187">(8条消息) C++ STL 迭代器Iterator、五种迭代器类别_Johnsonjjj的博客-CSDN博客</a> </p><h4 id="reverse-copy"><a href="#reverse-copy" class="headerlink" title="reverse_copy"></a>reverse_copy</h4><p>行为与reverse()类似，但是新序列会被复制到result所指的区间内</p><p>返回值为OutputIterator指出被复制的最后元素的下一个位置,原序列没有任何改变</p><p>reverse_copy(v.begin(),v.end(),v2.begin());</p><h4 id="rotate"><a href="#rotate" class="headerlink" title="rotate"></a>rotate</h4><p>将[first,middle)内的元素和[middle,last)内的元素互换</p><p>middle所指的元素会成为容器的第一个元素</p><p><u>相当于局部翻转</u></p><p>rotate()可以交换两个长度不同的区间</p><p>迭代器的移动能力，影响了这个算法的效率，所以设计为双层架构</p><p>rotate(v.begin(),v.begin()+4,v.end());</p><h4 id="rotate-copy"><a href="#rotate-copy" class="headerlink" title="rotate_copy"></a>rotate_copy</h4><p>行为类似rotate()，但产生出来的新序列会被置于result所指出的容器中</p><p>返回值为OutputIterator指出被复制的最后元素的下一个位置,原序列没有任何改变</p><p>rotate_copy(v.begin(),v.begin()+5,v.end(),v1.begin());</p><h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4><p>在序列一[first1,last1)所涵盖的区间中，查找序列二[first2,last2)的首次出现点</p><p>如果序列一内不存在与序列二完全匹配的子序列，便返回迭代器last1</p><p>两个版本：</p><p>第一个版本是指“两元素相等”</p><p>第二个版本是指允许用户指定一个二元运算</p><h4 id="search-n"><a href="#search-n" class="headerlink" title="search_n"></a>search_n</h4><p>在序列[first,last)所涵盖的区间中，查找”连续count个符合条件之元素”所形成的子序列</p><p>并返回一个迭代器指向改子序列的起始处。如果找不到子序列，就返回迭代器last</p><p>两个版本：</p><p>第一个版本是指“两元素相等”</p><p>第二个版本是指允许用户指定一个二元运算</p><p>iter1=search_n(v.begin(),v.end(),2,8); //查找“连续两个8”所形成的子序列起点</p><p>iter2=search_n(v.begin(),v.end(),3,8,less<int>());//查找连续三个小于8的元素所形成的子序列起点</int></p><h4 id="swap-ranges"><a href="#swap-ranges" class="headerlink" title="swap_ranges"></a>swap_ranges</h4><p>将[first1,last1) 区间内的元素与”从first2开始，个数相同”的元素互相交换</p><p>这两个序列可以位于同一个容器中，也可以位于不同容器中</p><p>源码判断为first1到达last1停止</p><p>所以第一序列小于或等于第二序列的长度</p><p>否则执行结果未可预料</p><p>swap_ranges(v.begin(),v.end(),v1.begin());</p><h4 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h4><p><img src="/../../../Typora/1664527575402-1664527601981.png" alt="1664527575402"></p><p>//两个版本：</p><p>//第一个版本作用于一个区间，一元操作</p><p>//第二个版本作用于两个区间，二元操作</p><p>transform(v.begin(),v.end(),v.begin(),bind2nd(minus<int>(),2));</int></p><p>// 改变区间的值，全部减2</p><p>transform(v.begin(),v.end(),v.begin(),v.begin(),plus<int>());</int></p><p>//第四个参数为存储结果的容器，第三参数为第二区间首元素</p><p>//改变区间的值，另第二区间的元素值加到第一区间的对应元素身上</p><p>//第二区间到元素个数不应小于第一区间的元素个数</p><h4 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h4><p>算法unique能够移除重复的元素。每当[first,last)内遇有重复元素群</p><p>它便移除元素群中第一个以后的元素</p><p>unique只移除相邻的重复元素</p><p>如果你想要移除所有重复元素，必须将序列排序，使所有重复元素都相邻</p><p><img src="/../../../Typora/1664528867829-1664864009902.png" alt="1664528867829"></p><p>unique(v.begin(),b.end());</p><p>源码使用adjacent_find()和unique_copy()实现</p><h4 id="unique-copy"><a href="#unique-copy" class="headerlink" title="unique_copy"></a>unique_copy</h4><p><img src="/../../../Typora/1664541068808-1664864009902.png" alt="1664541068808"></p><p><img src="/../../../Typora/1664541389803-1664864009902.png" alt="1664541389803">unique_copy(v.begin(),v.end(),v1.begin());</p><h4 id="lower-bound-应用于有序区间"><a href="#lower-bound-应用于有序区间" class="headerlink" title="lower_bound(应用于有序区间)"></a>lower_bound(应用于有序区间)</h4><p><img src="/../../../Typora/1664543771611-1664864009902.png" alt="1664543771611"></p><p>forward_iterator_tag版本</p><p>random_access_iterator_tag版本</p><p>lower_bound(v.begin(),v.end(),data);</p><p>lower_bound(v.begin(),v.end(),data，comp());</p><h4 id="upper-bound（应用于有序区间）"><a href="#upper-bound（应用于有序区间）" class="headerlink" title="upper_bound（应用于有序区间）"></a>upper_bound（应用于有序区间）</h4><p><img src="/../../../Typora/1664544328540-1664864009902.png" alt="1664544328540"></p><p>upper_bound(v.begin(),v.end(),data);</p><p>upper_bound(v.begin(),v.end(),data，comp());</p><p>forward_iterator_tag版本</p><p>random_access_iterator_tag版本</p><h4 id="binary-search-应用于有序序列"><a href="#binary-search-应用于有序序列" class="headerlink" title="binary_search(应用于有序序列)"></a>binary_search(应用于有序序列)</h4><p><img src="/../../../Typora/1664544639816-1664864009902.png" alt="1664544639816"></p><p>binary_search(v.begin(),v.end(),data);</p><p>binary_search(v.begin(),v.end(),data，comp());</p><h4 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next_permutation"></a>next_permutation</h4><p><img src="/../../../Typora/1664545623777-1664864009902.png" alt="1664545623777"></p><p>next_permutation(v.begin(),v.end());// 下一个排列组合</p><p>next_permutation(v.begin(),v.end()，comp());</p><p>从尾端往前寻找两个相邻元素i,ii，再从尾端开始往前检验j，找到比i大的元素</p><p>iter_swap()交换i与j，将ii后元素翻转reverse()</p><p><img src="/../../../Typora/1664546075414-1664864009902.png" alt="1664546075414"></p><h4 id="prev-permutation"><a href="#prev-permutation" class="headerlink" title="prev_permutation"></a>prev_permutation</h4><p><img src="/../../../Typora/1664546449121-1664864009902.png" alt="1664546449121"></p><p>prev_permutation(v.begin(),v.end());// 上一个排列组合</p><p>prev_permutation(v.begin(),v.end()，comp());</p><p>从尾端往前寻找两个相邻元素i,ii，且满足*i&gt;*ii再从尾端开始往前检验j,找到比i小的元素</p><p>iter_swap()交换i与j，将ii后元素翻转reverse()</p><p><img src="/../../../Typora/1664601822838-1664864009902.png" alt="1664601822838"></p><h4 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle"></a>random_shuffle</h4><p>这个算法将[first,last)的元素次序随机重排，也就是说，在N！中可能的元素排列顺序中随机选出一种，此处的N为last-first</p><p>N个元素的序列，其排列方式有N!种</p><p><img src="/../../../Typora/1664602819307-1664864009902.png" alt="1664602819307"></p><p><img src="/../../../Typora/1664603351490-1664864009902.png" alt="1664603351490"></p><p>random_shuffle(v.begin(),v.end()); // 随机重排</p><h4 id="partial-sort-x2F-partial-sort-copy"><a href="#partial-sort-x2F-partial-sort-copy" class="headerlink" title="partial_sort / partial_sort_copy"></a>partial_sort / partial_sort_copy</h4><p><img src="/../../../Typora/1664603618404-1664864009902.png" alt="1664603618404"></p><p><img src="/../../../Typora/1664603653064-1664864009902.png" alt="1664603653064"></p><p><img src="/../../../Typora/1664603903399-1664864009902.png" alt="1664603903399"></p><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><h5 id="不同排序算法时间效率比较"><a href="#不同排序算法时间效率比较" class="headerlink" title="不同排序算法时间效率比较"></a>不同排序算法时间效率比较</h5><p><img src="/../../../Typora/1664783312923-1664783473991-1664783478170.png" alt="1664783312923"></p><h5 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h5><p>复杂度为n^2</p><p><img src="/../../../Typora/1664605500243.png" alt="1664605500243"></p><p><img src="/../../../Typora/1664605523258-1664864009902.png" alt="1664605523258"></p><p><img src="/../../../Typora/1664605537383-1664864009902.png" alt="1664605537383"></p><p><img src="/../../../Typora/1664605548817-1664864009902.png" alt="1664605548817"></p><h5 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h5><p>目前已知最快的排序法</p><p>平均复杂度为N log N</p><p>最坏情况下将达到N^2</p><p>不过IntroSort 可将最坏情况推进到N log N</p><p><img src="/../../../Typora/1664607658301-1664864009902.png" alt="1664607658301"></p><p><img src="/../../../Typora/1664607667082-1664864009902.png" alt="1664607667082"></p><p><img src="/../../../Typora/1664607678867-1664864009902.png" alt="1664607678867"></p><p><img src="/../../../Typora/1664607693593-1664864009902.png" alt="1664607693593"></p><h5 id="threshold（阈值"><a href="#threshold（阈值" class="headerlink" title="threshold（阈值)"></a>threshold（阈值)</h5><p><img src="/../../../Typora/1664607991432-1664864009902.png" alt="1664607991432"></p><h5 id="final-insertion-sort"><a href="#final-insertion-sort" class="headerlink" title="final insertion sort"></a>final insertion sort</h5><p><img src="/../../../Typora/1664608189930-1664864009902.png" alt="1664608189930"></p><p>这样子insertion sort的内循环将很少执行，所以有很好的表现</p><h5 id="introsort"><a href="#introsort" class="headerlink" title="introsort"></a>introsort</h5><p><img src="/../../../Typora/1664608401500-1664864009902.png" alt="1664608401500"></p><p>heap sort 为make_heap构建完全二叉树，初始化heap为n时间复杂度</p><p>sort_heap为n log n时间复杂度</p><h5 id="SGI-STL-sort"><a href="#SGI-STL-sort" class="headerlink" title="SGI STL sort"></a>SGI STL sort</h5><p>sort()只适用于RandomAccessIterator</p><p>首先为常规的判断first!=last</p><p>使用_introsort_loop(first,last,value_type(first),_lg(last-first)*2);</p><p>//最后一个参数为_lg()用来控制分割恶化的情况</p><p>进入_introsort_loop()函数，判断序列是否分割恶化，恶化则将该序列调用heap_sort排序</p><p>否则继续分割（使用递归调用自身）</p><p>然后使用_final_insertion_sort()</p><p>先判断函数个数是否大于16,</p><p>是的话使用_insertion_sort()对两子序列进行排序，并调用_unguarded_insertion_sort()</p><p>否则调用_insertion_sort()</p><p> <img src="/../../../Typora/1664611974593-1664864009902.png" alt="1664611974593"></p><p><img src="/../../../Typora/1664611984206-1664864009902.png" alt="1664611984206"></p><p><img src="/../../../Typora/1664611995244-1664864009902.png" alt="1664611995244"></p><p><img src="/../../../Typora/1664612003298-1664864009902.png" alt="1664612003298"></p><p> _stl_threshold是个全局常数，稍早定义为const int 16</p><p>这个是来判断序列的大小，如果元素少，就使用插入排序</p><p><img src="/../../../Typora/1664783397978-1664864009902.png" alt="1664783397978"></p><p> 当递归层数较深时，待排区间内元素也不会很多了，在数据量较小的情况下，堆排和归并排序效率相当 </p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><img src="/../../../Typora/1664783674304-1664864009902.png" alt="1664783674304"></p><h4 id="equal-range-应用于有序序列"><a href="#equal-range-应用于有序序列" class="headerlink" title="equal_range(应用于有序序列)"></a>equal_range(应用于有序序列)</h4><p><img src="/../../../Typora/1664786237896-1664864009902.png" alt="1664786237896"></p><p><img src="/../../../Typora/1664786247864-1664864009902.png" alt="1664786247864"></p><p><img src="/../../../Typora/1664786259126-1664864009902.png" alt="1664786259126"></p><p>equal_range(v.begin(),v.end(),25);</p><p>两个版本,两种迭代器匹配：randomIterator和ForwardIterator</p><h4 id="inplace-merge-应用于有序区间"><a href="#inplace-merge-应用于有序区间" class="headerlink" title="inplace_merge(应用于有序区间)"></a>inplace_merge(应用于有序区间)</h4><p>该算法将两个连接在一起的有序序列结合成单一的一个序列</p><p>merge是将两个不连接在一起的有序序列结合成单一的一个序列</p><p><img src="/../../../Typora/1664788245974-1664864009902.png" alt="1664788245974"></p><p><img src="/../../../Typora/1664788258405-1664864009902.png" alt="1664788258405"></p><p><img src="/../../../Typora/1664788272316-1664864009903.png" alt="1664788272316"></p><p><img src="/../../../Typora/1664788288049-1664864009903.png" alt="1664788288049"></p><p><img src="/../../../Typora/1664788363082-1664788437521.png" alt="1664788363082"><img src="/../../../Typora/1664788307896-1664864009903.png" alt="1664788307896"></p><h4 id="nth-element"><a href="#nth-element" class="headerlink" title="nth_element"></a>nth_element</h4><p>nth_element(v.begin(),v.begin()+5,v.end());</p><p>//将小于*(v.begin()+5)的元素置于该元素之左</p><p>//其余置于该元素之右。不保证维持原有的相对位置（不保证局部有序）</p><p>nth_element(v.begin(),v.begin()+5,v.end(),greater<int>());</int></p><p><img src="/../../../Typora/1664790177565-1664864009903.png" alt="1664790177565"></p><p><img src="/../../../Typora/1664790192000-1664864009903.png" alt="1664790192000"></p><p><img src="/../../../Typora/1664790199592-1664864009903.png" alt="1664790199592"></p><h4 id="merge-sort（归并排序）"><a href="#merge-sort（归并排序）" class="headerlink" title="merge sort（归并排序）"></a>merge sort（归并排序）</h4><p><img src="/../../../Typora/1664790389492-1664864009903.png" alt="1664790389492"></p><p><img src="/../../../Typora/1664790398329-1664864009903.png" alt="1664790398329"></p><h1 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h1><p>任何应用程序欲使用STL内建的仿函数，都必须含有<functional>头文件</functional></p><h2 id="可配接的关键"><a href="#可配接的关键" class="headerlink" title="可配接的关键"></a>可配接的关键</h2><p><img src="/../../../Typora/1664797913251-1664864009903.png" alt="1664797913251"></p><p><img src="/../../../Typora/1664797922239-1664864009903.png" alt="1664797922239"></p><h3 id="unary-function"><a href="#unary-function" class="headerlink" title="unary_function"></a>unary_function</h3><p><img src="/../../../Typora/1664798107715-1664864009903.png" alt="1664798107715"></p><h3 id="binary-function"><a href="#binary-function" class="headerlink" title="binary_function"></a>binary_function</h3><p><img src="/../../../Typora/1664798494398-1664864009903.png" alt="1664798494398"></p><h3 id="算术类仿函数"><a href="#算术类仿函数" class="headerlink" title="算术类仿函数"></a>算术类仿函数</h3><p>仿函数的主要用途是为了搭配STL算法</p><p><img src="/../../../Typora/1664798664060-1664864009903.png" alt="1664798664060"></p><h3 id="关系运算类仿函数"><a href="#关系运算类仿函数" class="headerlink" title="关系运算类仿函数"></a>关系运算类仿函数</h3><p><img src="/../../../Typora/1664798937124-1664864009903.png" alt="1664798937124"></p><p><img src="/../../../Typora/1664798949284-1664864009903.png" alt="1664798949284"></p><h3 id="逻辑运算类仿函数"><a href="#逻辑运算类仿函数" class="headerlink" title="逻辑运算类仿函数"></a>逻辑运算类仿函数</h3><p><img src="/../../../Typora/1664799066566-1664864009903.png" alt="1664799066566"></p><h3 id="证同，选择，投射"><a href="#证同，选择，投射" class="headerlink" title="证同，选择，投射"></a>证同，选择，投射</h3><p><img src="/../../../Typora/1664799244805-1664864009903.png" alt="1664799244805"></p><h1 id="配接器"><a href="#配接器" class="headerlink" title="配接器"></a>配接器</h1><p>配接器在STL组件的灵活组合运用功能上，扮演者轴承，转换器的角色</p><h2 id="配接器之概括与分类"><a href="#配接器之概括与分类" class="headerlink" title="配接器之概括与分类"></a>配接器之概括与分类</h2><p><img src="/../../../Typora/1664799468574-1664864009903.png" alt="1664799468574"></p><p><img src="/../../../Typora/1664799537420-1664864009903.png" alt="1664799537420"></p><h3 id="应用于仿函数，functor-adapters"><a href="#应用于仿函数，functor-adapters" class="headerlink" title="应用于仿函数，functor adapters"></a>应用于仿函数，functor adapters</h3><p>C++ Standard规定这些配接器的接口可由<functional>获得，SGI STL 则将他们实际定义于&lt;stl_functional.h&gt;</functional></p><p><img src="/../../../Typora/1664802105722-1664864009903.png" alt="1664802105722"></p><p><img src="/../../../Typora/1664802117479-1664864009903.png" alt="1664802117479"></p><h3 id="container-adapters"><a href="#container-adapters" class="headerlink" title="container adapters"></a>container adapters</h3><p><img src="/../../../Typora/1664802280474-1664864009903.png" alt="1664802280474"></p><h3 id="iterator-adapters"><a href="#iterator-adapters" class="headerlink" title="iterator adapters"></a>iterator adapters</h3><p><em><strong>插入型迭代器</strong></em><br>Insert迭代器为Inserters,用来将“赋值新值”操作转换为“安插新值”操作；<br>算法可以执行安插行为而非覆盖行为<br>所有Insert迭代器属于Output迭代器类型，只提供赋值能力；<br>Insert迭代器吧上述的赋值动作转为安插动作</p><p>运算符“*”传回迭代器当前的位置<br>然后由operator=赋值新值<br>Insert迭代器的技巧：</p><p>operator<em>在实际操作中被认为是一个无实际操作的动作，简单传回</em>this,对Insert迭代器来说，*pos 和pos等价；<br>赋值动作被转化插入动作；事实上Insert迭代器会调用容器的push_back(),push_front(),insert()等成员函数；<br>对与一个insert迭代器，插入新值： *pos = value；</p><p>Insert迭代器的分类：区别在于插入位置</p><p>后插入型<br>前插入型<br>产生型<br>分类：</p><p>名称                                class                   其所调用的函数      生成函数<br>BackInserterback_insert_iterator push_back        back_inserter(cont)<br>FrontInserterfonrt_insert_iteratorpush_front      front_inserter(cont)<br>GeneralInsterinsert_iterator         Insert(pos,value)Inserter(cont, pos)<br>容器本身需要支持Insert迭代器所调用的函数，否则该Insert迭代器就不可用；</p><ul><li><p>back_inserter: 支持vector,deque,list, string·容器</p></li><li><p>front_inserter: 支持deque, list 容器<br>————————————————<br>版权声明：本文为CSDN博主「jingza」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/jingza/article/details/77248862">https://blog.csdn.net/jingza/article/details/77248862</a></p></li></ul><p>ostream_iterator<int>outite(cout,” “);</int></p><h3 id="reverse-iterator"><a href="#reverse-iterator" class="headerlink" title="reverse iterator"></a>reverse iterator</h3><p><img src="/../../../Typora/1664803457740-1664864009903.png" alt="1664803457740"></p><p><img src="/../../../Typora/1664803616564-1664864009903.png" alt="1664803616564"></p><p>reverse_iterator&lt;deque<int>::iterator&gt;(id.end());</int></p><p>deque<int>::reverse_iterator(id.end());</int></p><p><img src="/../../../Typora/1664805168686-1664864009903.png" alt="1664805168686"></p><p><img src="/1664805208474-1664864009903.png" alt="1664805208474"></p><h3 id="stream-iterator"><a href="#stream-iterator" class="headerlink" title="stream iterator"></a>stream iterator</h3><ul><li><p><em><u><strong>流迭代器</strong></u></em></p><p>流迭代器是一种迭代器配接器，可以把流当做算法的原点和终点；<br>流迭代器是特殊用途的输入和输出迭代器，程序能管理与I/o相关的数据；<br>istream 迭代器从input stream中读取元素；ostream迭代器对Output stream写入元素。<br>流迭代器的特殊形式：stream缓冲区迭代器<br>1.ostream迭代器<br>ostream迭代器将值写入到Output stream中。<br>ostream迭代器赋值操作转化为运算符operator&lt;&lt;</p></li></ul><p>ostream迭代器的各项工作<br>算式效果<br>ostream_iterator<t>(ostream)为ostream产生一个ostream迭代器<br>ostream_iterator<t>(ostream,delim)为ostream产生一个ostream迭代器，各元素间以delim作为分隔符<br>*iter无实际操作<br>Iter = value将value写入到ostream， 如ostream &lt;&lt; value<br>++ iter无实际操作<br>Iter ++无实际操作</t></t></p><ol><li>生成迭代器的时候，必须提供一个 outputstream作为参数，迭代器会将元素写入到此Output stream身上；</li><li>另一个参数可有可无，是一个字符串，作为元素之间的分隔符。分割符的类型 cosnt char*,如果使用string类型，需要转换，如使用c_str()</li></ol><p>例子：</p><p>—————省略——————-<br>vector<int> vec2 = {1,2,3,4,5,6,7,8};<br>cout &lt;&lt; “ vec2: “;<br>copy(vec2.begin(), vec2.end(), ostream_iterator<int>(cout,” “));<br>cout &lt;&lt; endl;<br>—————省略——————-<br>1<br>2<br>3<br>4<br>5<br>6<br>结果为：</int></int></p><p>vec2: 1 2 3 4 5 6 7 8<br>1</p><p><em><strong>istream迭代器</strong></em><br>用于从input stream中读取元素。<br>一般经过从input迭代器的通用接口，利用operator&gt;&gt;读取元素，操作可能失败，算法需要知道终点<br>为了解决这个问题： 使用 end-of-stream，他利用istream迭代器默认构造函数生成。<br>只要读取失败一次，istream迭代器就变成了end-of-stream，读取结束，可以将两个迭代器进行比较<br>istream迭代器的操作：</p><p>算式效果<br>istream_iterator<t>()产生一个end-of-stream迭代器<br>istream_iterator<t>(istream)为istream产生一个istream迭代器（可能立即读取一个元素）<br>*iter传回先去读取的值（如果构造函数没有读取第一个元素的值，则本式子执行读取任务）<br>iter-&gt;member传回读取元素的成员<br>++iter读取下一个元素并返回其位置<br>iter ++读取下一个元素，传回迭代器指向的前一个元素<br>iter1 == iter2检验 iter1 和iter2是否相等<br>iter1！= iter2检验iter1 和iter2是否不等<br>istream迭代器的模板：</t></t></p><p>template&lt; class T,class CharT = char,<br>                class Traits = std::char_traits<chart>,<br>                class Distance = std::ptrdiff_t &gt;<br>class istream_iterator: public std::iterator&lt;std::input_iterator_tag, T, Distance, const T*, const T&amp;&gt;<br>1<br>2<br>3<br>4<br>第一个参数是数据类型<br>第二个和第三个参数确定stream类别<br>第四个参数表示指定迭代器距离表示的型别；<br>两个istream迭代器相等的条件：</chart></p><p>两者都是end-of-stream迭代器<br>两个都可以进行读取操作，并指向相同的stream;<br>例子：</p><p>—————省略—————-<br>istream_iterator<int> inputcin(cin);//cin迭代器<br>istream_iterator<int> eof;//流结束迭代器</int></int></p><p>while (inputcin != eof){<br>    vec1.push_back(*inputcin);<br>    ++inputcin;<br>}<br>—————省略—————-<br>使用<code>CTRL +　Z</code>输入空白，结束<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>结果为：</p><p>1 2 3 4 5 6 7  8 9<br>^Z<br> vec1: 1   2   3   4   5   6   7   8   9<br>————————————————<br>版权声明：本文为CSDN博主「jingza」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/jingza/article/details/77248862">https://blog.csdn.net/jingza/article/details/77248862</a></p><h3 id="ptr-fun"><a href="#ptr-fun" class="headerlink" title="ptr_fun"></a>ptr_fun</h3><p>这种配接器使我们能够将一般函数当做仿函数使用</p><p>如果你不使用这里·所说的两个配接器先做一番包装，你所使用的那个一般函数将无配接能力，也就无法和前数小节介绍过的其它配接器接轨</p><h3 id="用于成员函数指针：mem-fun-mem-fun-ref"><a href="#用于成员函数指针：mem-fun-mem-fun-ref" class="headerlink" title="用于成员函数指针：mem_fun,mem_fun_ref"></a>用于成员函数指针：mem_fun,mem_fun_ref</h3><p>这种配接器能够将成员函数当做仿函数来使用</p><p>for_each(v.begin(),v.end(),mem_fun(&amp;Shape::display))</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/09/29/hello-world/"/>
      <url>/2022/09/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
